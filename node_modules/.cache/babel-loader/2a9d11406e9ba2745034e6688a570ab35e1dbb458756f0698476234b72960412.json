{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\n// istanbul ignore next\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    'default': obj\n  };\n}\nvar _visitor = require('./visitor');\nvar _visitor2 = _interopRequireDefault(_visitor);\nfunction WhitespaceControl() {\n  var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n  this.options = options;\n}\nWhitespaceControl.prototype = new _visitor2['default']();\nWhitespaceControl.prototype.Program = function (program) {\n  var doStandalone = !this.options.ignoreStandalone;\n  var isRoot = !this.isRootSeen;\n  this.isRootSeen = true;\n  var body = program.body;\n  for (var i = 0, l = body.length; i < l; i++) {\n    var current = body[i],\n      strip = this.accept(current);\n    if (!strip) {\n      continue;\n    }\n    var _isPrevWhitespace = isPrevWhitespace(body, i, isRoot),\n      _isNextWhitespace = isNextWhitespace(body, i, isRoot),\n      openStandalone = strip.openStandalone && _isPrevWhitespace,\n      closeStandalone = strip.closeStandalone && _isNextWhitespace,\n      inlineStandalone = strip.inlineStandalone && _isPrevWhitespace && _isNextWhitespace;\n    if (strip.close) {\n      omitRight(body, i, true);\n    }\n    if (strip.open) {\n      omitLeft(body, i, true);\n    }\n    if (doStandalone && inlineStandalone) {\n      omitRight(body, i);\n      if (omitLeft(body, i)) {\n        // If we are on a standalone node, save the indent info for partials\n        if (current.type === 'PartialStatement') {\n          // Pull out the whitespace from the final line\n          current.indent = /([ \\t]+$)/.exec(body[i - 1].original)[1];\n        }\n      }\n    }\n    if (doStandalone && openStandalone) {\n      omitRight((current.program || current.inverse).body);\n\n      // Strip out the previous content node if it's whitespace only\n      omitLeft(body, i);\n    }\n    if (doStandalone && closeStandalone) {\n      // Always strip the next node\n      omitRight(body, i);\n      omitLeft((current.inverse || current.program).body);\n    }\n  }\n  return program;\n};\nWhitespaceControl.prototype.BlockStatement = WhitespaceControl.prototype.DecoratorBlock = WhitespaceControl.prototype.PartialBlockStatement = function (block) {\n  this.accept(block.program);\n  this.accept(block.inverse);\n\n  // Find the inverse program that is involed with whitespace stripping.\n  var program = block.program || block.inverse,\n    inverse = block.program && block.inverse,\n    firstInverse = inverse,\n    lastInverse = inverse;\n  if (inverse && inverse.chained) {\n    firstInverse = inverse.body[0].program;\n\n    // Walk the inverse chain to find the last inverse that is actually in the chain.\n    while (lastInverse.chained) {\n      lastInverse = lastInverse.body[lastInverse.body.length - 1].program;\n    }\n  }\n  var strip = {\n    open: block.openStrip.open,\n    close: block.closeStrip.close,\n    // Determine the standalone candiacy. Basically flag our content as being possibly standalone\n    // so our parent can determine if we actually are standalone\n    openStandalone: isNextWhitespace(program.body),\n    closeStandalone: isPrevWhitespace((firstInverse || program).body)\n  };\n  if (block.openStrip.close) {\n    omitRight(program.body, null, true);\n  }\n  if (inverse) {\n    var inverseStrip = block.inverseStrip;\n    if (inverseStrip.open) {\n      omitLeft(program.body, null, true);\n    }\n    if (inverseStrip.close) {\n      omitRight(firstInverse.body, null, true);\n    }\n    if (block.closeStrip.open) {\n      omitLeft(lastInverse.body, null, true);\n    }\n\n    // Find standalone else statments\n    if (!this.options.ignoreStandalone && isPrevWhitespace(program.body) && isNextWhitespace(firstInverse.body)) {\n      omitLeft(program.body);\n      omitRight(firstInverse.body);\n    }\n  } else if (block.closeStrip.open) {\n    omitLeft(program.body, null, true);\n  }\n  return strip;\n};\nWhitespaceControl.prototype.Decorator = WhitespaceControl.prototype.MustacheStatement = function (mustache) {\n  return mustache.strip;\n};\nWhitespaceControl.prototype.PartialStatement = WhitespaceControl.prototype.CommentStatement = function (node) {\n  /* istanbul ignore next */\n  var strip = node.strip || {};\n  return {\n    inlineStandalone: true,\n    open: strip.open,\n    close: strip.close\n  };\n};\nfunction isPrevWhitespace(body, i, isRoot) {\n  if (i === undefined) {\n    i = body.length;\n  }\n\n  // Nodes that end with newlines are considered whitespace (but are special\n  // cased for strip operations)\n  var prev = body[i - 1],\n    sibling = body[i - 2];\n  if (!prev) {\n    return isRoot;\n  }\n  if (prev.type === 'ContentStatement') {\n    return (sibling || !isRoot ? /\\r?\\n\\s*?$/ : /(^|\\r?\\n)\\s*?$/).test(prev.original);\n  }\n}\nfunction isNextWhitespace(body, i, isRoot) {\n  if (i === undefined) {\n    i = -1;\n  }\n  var next = body[i + 1],\n    sibling = body[i + 2];\n  if (!next) {\n    return isRoot;\n  }\n  if (next.type === 'ContentStatement') {\n    return (sibling || !isRoot ? /^\\s*?\\r?\\n/ : /^\\s*?(\\r?\\n|$)/).test(next.original);\n  }\n}\n\n// Marks the node to the right of the position as omitted.\n// I.e. {{foo}}' ' will mark the ' ' node as omitted.\n//\n// If i is undefined, then the first child will be marked as such.\n//\n// If mulitple is truthy then all whitespace will be stripped out until non-whitespace\n// content is met.\nfunction omitRight(body, i, multiple) {\n  var current = body[i == null ? 0 : i + 1];\n  if (!current || current.type !== 'ContentStatement' || !multiple && current.rightStripped) {\n    return;\n  }\n  var original = current.value;\n  current.value = current.value.replace(multiple ? /^\\s+/ : /^[ \\t]*\\r?\\n?/, '');\n  current.rightStripped = current.value !== original;\n}\n\n// Marks the node to the left of the position as omitted.\n// I.e. ' '{{foo}} will mark the ' ' node as omitted.\n//\n// If i is undefined then the last child will be marked as such.\n//\n// If mulitple is truthy then all whitespace will be stripped out until non-whitespace\n// content is met.\nfunction omitLeft(body, i, multiple) {\n  var current = body[i == null ? body.length - 1 : i - 1];\n  if (!current || current.type !== 'ContentStatement' || !multiple && current.leftStripped) {\n    return;\n  }\n\n  // We omit the last node if it's whitespace only and not preceded by a non-content node.\n  var original = current.value;\n  current.value = current.value.replace(multiple ? /\\s+$/ : /[ \\t]+$/, '');\n  current.leftStripped = current.value !== original;\n  return current.leftStripped;\n}\nexports['default'] = WhitespaceControl;\nmodule.exports = exports['default'];","map":{"version":3,"names":["WhitespaceControl","options","arguments","length","undefined","prototype","_visitor2","Program","program","doStandalone","ignoreStandalone","isRoot","isRootSeen","body","i","l","current","strip","accept","_isPrevWhitespace","isPrevWhitespace","_isNextWhitespace","isNextWhitespace","openStandalone","closeStandalone","inlineStandalone","close","omitRight","open","omitLeft","type","indent","exec","original","inverse","BlockStatement","DecoratorBlock","PartialBlockStatement","block","firstInverse","lastInverse","chained","openStrip","closeStrip","inverseStrip","Decorator","MustacheStatement","mustache","PartialStatement","CommentStatement","node","prev","sibling","test","next","multiple","rightStripped","value","replace","leftStripped"],"sources":["/home/kaushik/Documents/Projects/template-filler/node_modules/handlebars/lib/handlebars/compiler/whitespace-control.js"],"sourcesContent":["import Visitor from './visitor';\n\nfunction WhitespaceControl(options = {}) {\n  this.options = options;\n}\nWhitespaceControl.prototype = new Visitor();\n\nWhitespaceControl.prototype.Program = function(program) {\n  const doStandalone = !this.options.ignoreStandalone;\n\n  let isRoot = !this.isRootSeen;\n  this.isRootSeen = true;\n\n  let body = program.body;\n  for (let i = 0, l = body.length; i < l; i++) {\n    let current = body[i],\n      strip = this.accept(current);\n\n    if (!strip) {\n      continue;\n    }\n\n    let _isPrevWhitespace = isPrevWhitespace(body, i, isRoot),\n      _isNextWhitespace = isNextWhitespace(body, i, isRoot),\n      openStandalone = strip.openStandalone && _isPrevWhitespace,\n      closeStandalone = strip.closeStandalone && _isNextWhitespace,\n      inlineStandalone =\n        strip.inlineStandalone && _isPrevWhitespace && _isNextWhitespace;\n\n    if (strip.close) {\n      omitRight(body, i, true);\n    }\n    if (strip.open) {\n      omitLeft(body, i, true);\n    }\n\n    if (doStandalone && inlineStandalone) {\n      omitRight(body, i);\n\n      if (omitLeft(body, i)) {\n        // If we are on a standalone node, save the indent info for partials\n        if (current.type === 'PartialStatement') {\n          // Pull out the whitespace from the final line\n          current.indent = /([ \\t]+$)/.exec(body[i - 1].original)[1];\n        }\n      }\n    }\n    if (doStandalone && openStandalone) {\n      omitRight((current.program || current.inverse).body);\n\n      // Strip out the previous content node if it's whitespace only\n      omitLeft(body, i);\n    }\n    if (doStandalone && closeStandalone) {\n      // Always strip the next node\n      omitRight(body, i);\n\n      omitLeft((current.inverse || current.program).body);\n    }\n  }\n\n  return program;\n};\n\nWhitespaceControl.prototype.BlockStatement = WhitespaceControl.prototype.DecoratorBlock = WhitespaceControl.prototype.PartialBlockStatement = function(\n  block\n) {\n  this.accept(block.program);\n  this.accept(block.inverse);\n\n  // Find the inverse program that is involed with whitespace stripping.\n  let program = block.program || block.inverse,\n    inverse = block.program && block.inverse,\n    firstInverse = inverse,\n    lastInverse = inverse;\n\n  if (inverse && inverse.chained) {\n    firstInverse = inverse.body[0].program;\n\n    // Walk the inverse chain to find the last inverse that is actually in the chain.\n    while (lastInverse.chained) {\n      lastInverse = lastInverse.body[lastInverse.body.length - 1].program;\n    }\n  }\n\n  let strip = {\n    open: block.openStrip.open,\n    close: block.closeStrip.close,\n\n    // Determine the standalone candiacy. Basically flag our content as being possibly standalone\n    // so our parent can determine if we actually are standalone\n    openStandalone: isNextWhitespace(program.body),\n    closeStandalone: isPrevWhitespace((firstInverse || program).body)\n  };\n\n  if (block.openStrip.close) {\n    omitRight(program.body, null, true);\n  }\n\n  if (inverse) {\n    let inverseStrip = block.inverseStrip;\n\n    if (inverseStrip.open) {\n      omitLeft(program.body, null, true);\n    }\n\n    if (inverseStrip.close) {\n      omitRight(firstInverse.body, null, true);\n    }\n    if (block.closeStrip.open) {\n      omitLeft(lastInverse.body, null, true);\n    }\n\n    // Find standalone else statments\n    if (\n      !this.options.ignoreStandalone &&\n      isPrevWhitespace(program.body) &&\n      isNextWhitespace(firstInverse.body)\n    ) {\n      omitLeft(program.body);\n      omitRight(firstInverse.body);\n    }\n  } else if (block.closeStrip.open) {\n    omitLeft(program.body, null, true);\n  }\n\n  return strip;\n};\n\nWhitespaceControl.prototype.Decorator = WhitespaceControl.prototype.MustacheStatement = function(\n  mustache\n) {\n  return mustache.strip;\n};\n\nWhitespaceControl.prototype.PartialStatement = WhitespaceControl.prototype.CommentStatement = function(\n  node\n) {\n  /* istanbul ignore next */\n  let strip = node.strip || {};\n  return {\n    inlineStandalone: true,\n    open: strip.open,\n    close: strip.close\n  };\n};\n\nfunction isPrevWhitespace(body, i, isRoot) {\n  if (i === undefined) {\n    i = body.length;\n  }\n\n  // Nodes that end with newlines are considered whitespace (but are special\n  // cased for strip operations)\n  let prev = body[i - 1],\n    sibling = body[i - 2];\n  if (!prev) {\n    return isRoot;\n  }\n\n  if (prev.type === 'ContentStatement') {\n    return (sibling || !isRoot ? /\\r?\\n\\s*?$/ : /(^|\\r?\\n)\\s*?$/).test(\n      prev.original\n    );\n  }\n}\nfunction isNextWhitespace(body, i, isRoot) {\n  if (i === undefined) {\n    i = -1;\n  }\n\n  let next = body[i + 1],\n    sibling = body[i + 2];\n  if (!next) {\n    return isRoot;\n  }\n\n  if (next.type === 'ContentStatement') {\n    return (sibling || !isRoot ? /^\\s*?\\r?\\n/ : /^\\s*?(\\r?\\n|$)/).test(\n      next.original\n    );\n  }\n}\n\n// Marks the node to the right of the position as omitted.\n// I.e. {{foo}}' ' will mark the ' ' node as omitted.\n//\n// If i is undefined, then the first child will be marked as such.\n//\n// If mulitple is truthy then all whitespace will be stripped out until non-whitespace\n// content is met.\nfunction omitRight(body, i, multiple) {\n  let current = body[i == null ? 0 : i + 1];\n  if (\n    !current ||\n    current.type !== 'ContentStatement' ||\n    (!multiple && current.rightStripped)\n  ) {\n    return;\n  }\n\n  let original = current.value;\n  current.value = current.value.replace(\n    multiple ? /^\\s+/ : /^[ \\t]*\\r?\\n?/,\n    ''\n  );\n  current.rightStripped = current.value !== original;\n}\n\n// Marks the node to the left of the position as omitted.\n// I.e. ' '{{foo}} will mark the ' ' node as omitted.\n//\n// If i is undefined then the last child will be marked as such.\n//\n// If mulitple is truthy then all whitespace will be stripped out until non-whitespace\n// content is met.\nfunction omitLeft(body, i, multiple) {\n  let current = body[i == null ? body.length - 1 : i - 1];\n  if (\n    !current ||\n    current.type !== 'ContentStatement' ||\n    (!multiple && current.leftStripped)\n  ) {\n    return;\n  }\n\n  // We omit the last node if it's whitespace only and not preceded by a non-content node.\n  let original = current.value;\n  current.value = current.value.replace(multiple ? /\\s+$/ : /[ \\t]+$/, '');\n  current.leftStripped = current.value !== original;\n  return current.leftStripped;\n}\n\nexport default WhitespaceControl;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}