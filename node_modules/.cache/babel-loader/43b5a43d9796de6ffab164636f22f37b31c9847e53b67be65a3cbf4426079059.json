{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\n// istanbul ignore next\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    'default': obj\n  };\n}\nvar _base = require('../base');\nvar _exception = require('../exception');\nvar _exception2 = _interopRequireDefault(_exception);\nvar _utils = require('../utils');\nvar _codeGen = require('./code-gen');\nvar _codeGen2 = _interopRequireDefault(_codeGen);\nfunction Literal(value) {\n  this.value = value;\n}\nfunction JavaScriptCompiler() {}\nJavaScriptCompiler.prototype = {\n  // PUBLIC API: You can override these methods in a subclass to provide\n  // alternative compiled forms for name lookup and buffering semantics\n  nameLookup: function nameLookup(parent, name /*,  type */) {\n    return this.internalNameLookup(parent, name);\n  },\n  depthedLookup: function depthedLookup(name) {\n    return [this.aliasable('container.lookup'), '(depths, ', JSON.stringify(name), ')'];\n  },\n  compilerInfo: function compilerInfo() {\n    var revision = _base.COMPILER_REVISION,\n      versions = _base.REVISION_CHANGES[revision];\n    return [revision, versions];\n  },\n  appendToBuffer: function appendToBuffer(source, location, explicit) {\n    // Force a source as this simplifies the merge logic.\n    if (!_utils.isArray(source)) {\n      source = [source];\n    }\n    source = this.source.wrap(source, location);\n    if (this.environment.isSimple) {\n      return ['return ', source, ';'];\n    } else if (explicit) {\n      // This is a case where the buffer operation occurs as a child of another\n      // construct, generally braces. We have to explicitly output these buffer\n      // operations to ensure that the emitted code goes in the correct location.\n      return ['buffer += ', source, ';'];\n    } else {\n      source.appendToBuffer = true;\n      return source;\n    }\n  },\n  initializeBuffer: function initializeBuffer() {\n    return this.quotedString('');\n  },\n  // END PUBLIC API\n  internalNameLookup: function internalNameLookup(parent, name) {\n    this.lookupPropertyFunctionIsUsed = true;\n    return ['lookupProperty(', parent, ',', JSON.stringify(name), ')'];\n  },\n  lookupPropertyFunctionIsUsed: false,\n  compile: function compile(environment, options, context, asObject) {\n    this.environment = environment;\n    this.options = options;\n    this.stringParams = this.options.stringParams;\n    this.trackIds = this.options.trackIds;\n    this.precompile = !asObject;\n    this.name = this.environment.name;\n    this.isChild = !!context;\n    this.context = context || {\n      decorators: [],\n      programs: [],\n      environments: []\n    };\n    this.preamble();\n    this.stackSlot = 0;\n    this.stackVars = [];\n    this.aliases = {};\n    this.registers = {\n      list: []\n    };\n    this.hashes = [];\n    this.compileStack = [];\n    this.inlineStack = [];\n    this.blockParams = [];\n    this.compileChildren(environment, options);\n    this.useDepths = this.useDepths || environment.useDepths || environment.useDecorators || this.options.compat;\n    this.useBlockParams = this.useBlockParams || environment.useBlockParams;\n    var opcodes = environment.opcodes,\n      opcode = undefined,\n      firstLoc = undefined,\n      i = undefined,\n      l = undefined;\n    for (i = 0, l = opcodes.length; i < l; i++) {\n      opcode = opcodes[i];\n      this.source.currentLocation = opcode.loc;\n      firstLoc = firstLoc || opcode.loc;\n      this[opcode.opcode].apply(this, opcode.args);\n    }\n\n    // Flush any trailing content that might be pending.\n    this.source.currentLocation = firstLoc;\n    this.pushSource('');\n\n    /* istanbul ignore next */\n    if (this.stackSlot || this.inlineStack.length || this.compileStack.length) {\n      throw new _exception2['default']('Compile completed with content left on stack');\n    }\n    if (!this.decorators.isEmpty()) {\n      this.useDecorators = true;\n      this.decorators.prepend(['var decorators = container.decorators, ', this.lookupPropertyFunctionVarDeclaration(), ';\\n']);\n      this.decorators.push('return fn;');\n      if (asObject) {\n        this.decorators = Function.apply(this, ['fn', 'props', 'container', 'depth0', 'data', 'blockParams', 'depths', this.decorators.merge()]);\n      } else {\n        this.decorators.prepend('function(fn, props, container, depth0, data, blockParams, depths) {\\n');\n        this.decorators.push('}\\n');\n        this.decorators = this.decorators.merge();\n      }\n    } else {\n      this.decorators = undefined;\n    }\n    var fn = this.createFunctionContext(asObject);\n    if (!this.isChild) {\n      var ret = {\n        compiler: this.compilerInfo(),\n        main: fn\n      };\n      if (this.decorators) {\n        ret.main_d = this.decorators; // eslint-disable-line camelcase\n        ret.useDecorators = true;\n      }\n      var _context = this.context;\n      var programs = _context.programs;\n      var decorators = _context.decorators;\n      for (i = 0, l = programs.length; i < l; i++) {\n        if (programs[i]) {\n          ret[i] = programs[i];\n          if (decorators[i]) {\n            ret[i + '_d'] = decorators[i];\n            ret.useDecorators = true;\n          }\n        }\n      }\n      if (this.environment.usePartial) {\n        ret.usePartial = true;\n      }\n      if (this.options.data) {\n        ret.useData = true;\n      }\n      if (this.useDepths) {\n        ret.useDepths = true;\n      }\n      if (this.useBlockParams) {\n        ret.useBlockParams = true;\n      }\n      if (this.options.compat) {\n        ret.compat = true;\n      }\n      if (!asObject) {\n        ret.compiler = JSON.stringify(ret.compiler);\n        this.source.currentLocation = {\n          start: {\n            line: 1,\n            column: 0\n          }\n        };\n        ret = this.objectLiteral(ret);\n        if (options.srcName) {\n          ret = ret.toStringWithSourceMap({\n            file: options.destName\n          });\n          ret.map = ret.map && ret.map.toString();\n        } else {\n          ret = ret.toString();\n        }\n      } else {\n        ret.compilerOptions = this.options;\n      }\n      return ret;\n    } else {\n      return fn;\n    }\n  },\n  preamble: function preamble() {\n    // track the last context pushed into place to allow skipping the\n    // getContext opcode when it would be a noop\n    this.lastContext = 0;\n    this.source = new _codeGen2['default'](this.options.srcName);\n    this.decorators = new _codeGen2['default'](this.options.srcName);\n  },\n  createFunctionContext: function createFunctionContext(asObject) {\n    // istanbul ignore next\n\n    var _this = this;\n    var varDeclarations = '';\n    var locals = this.stackVars.concat(this.registers.list);\n    if (locals.length > 0) {\n      varDeclarations += ', ' + locals.join(', ');\n    }\n\n    // Generate minimizer alias mappings\n    //\n    // When using true SourceNodes, this will update all references to the given alias\n    // as the source nodes are reused in situ. For the non-source node compilation mode,\n    // aliases will not be used, but this case is already being run on the client and\n    // we aren't concern about minimizing the template size.\n    var aliasCount = 0;\n    Object.keys(this.aliases).forEach(function (alias) {\n      var node = _this.aliases[alias];\n      if (node.children && node.referenceCount > 1) {\n        varDeclarations += ', alias' + ++aliasCount + '=' + alias;\n        node.children[0] = 'alias' + aliasCount;\n      }\n    });\n    if (this.lookupPropertyFunctionIsUsed) {\n      varDeclarations += ', ' + this.lookupPropertyFunctionVarDeclaration();\n    }\n    var params = ['container', 'depth0', 'helpers', 'partials', 'data'];\n    if (this.useBlockParams || this.useDepths) {\n      params.push('blockParams');\n    }\n    if (this.useDepths) {\n      params.push('depths');\n    }\n\n    // Perform a second pass over the output to merge content when possible\n    var source = this.mergeSource(varDeclarations);\n    if (asObject) {\n      params.push(source);\n      return Function.apply(this, params);\n    } else {\n      return this.source.wrap(['function(', params.join(','), ') {\\n  ', source, '}']);\n    }\n  },\n  mergeSource: function mergeSource(varDeclarations) {\n    var isSimple = this.environment.isSimple,\n      appendOnly = !this.forceBuffer,\n      appendFirst = undefined,\n      sourceSeen = undefined,\n      bufferStart = undefined,\n      bufferEnd = undefined;\n    this.source.each(function (line) {\n      if (line.appendToBuffer) {\n        if (bufferStart) {\n          line.prepend('  + ');\n        } else {\n          bufferStart = line;\n        }\n        bufferEnd = line;\n      } else {\n        if (bufferStart) {\n          if (!sourceSeen) {\n            appendFirst = true;\n          } else {\n            bufferStart.prepend('buffer += ');\n          }\n          bufferEnd.add(';');\n          bufferStart = bufferEnd = undefined;\n        }\n        sourceSeen = true;\n        if (!isSimple) {\n          appendOnly = false;\n        }\n      }\n    });\n    if (appendOnly) {\n      if (bufferStart) {\n        bufferStart.prepend('return ');\n        bufferEnd.add(';');\n      } else if (!sourceSeen) {\n        this.source.push('return \"\";');\n      }\n    } else {\n      varDeclarations += ', buffer = ' + (appendFirst ? '' : this.initializeBuffer());\n      if (bufferStart) {\n        bufferStart.prepend('return buffer + ');\n        bufferEnd.add(';');\n      } else {\n        this.source.push('return buffer;');\n      }\n    }\n    if (varDeclarations) {\n      this.source.prepend('var ' + varDeclarations.substring(2) + (appendFirst ? '' : ';\\n'));\n    }\n    return this.source.merge();\n  },\n  lookupPropertyFunctionVarDeclaration: function lookupPropertyFunctionVarDeclaration() {\n    return '\\n      lookupProperty = container.lookupProperty || function(parent, propertyName) {\\n        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {\\n          return parent[propertyName];\\n        }\\n        return undefined\\n    }\\n    '.trim();\n  },\n  // [blockValue]\n  //\n  // On stack, before: hash, inverse, program, value\n  // On stack, after: return value of blockHelperMissing\n  //\n  // The purpose of this opcode is to take a block of the form\n  // `{{#this.foo}}...{{/this.foo}}`, resolve the value of `foo`, and\n  // replace it on the stack with the result of properly\n  // invoking blockHelperMissing.\n  blockValue: function blockValue(name) {\n    var blockHelperMissing = this.aliasable('container.hooks.blockHelperMissing'),\n      params = [this.contextName(0)];\n    this.setupHelperArgs(name, 0, params);\n    var blockName = this.popStack();\n    params.splice(1, 0, blockName);\n    this.push(this.source.functionCall(blockHelperMissing, 'call', params));\n  },\n  // [ambiguousBlockValue]\n  //\n  // On stack, before: hash, inverse, program, value\n  // Compiler value, before: lastHelper=value of last found helper, if any\n  // On stack, after, if no lastHelper: same as [blockValue]\n  // On stack, after, if lastHelper: value\n  ambiguousBlockValue: function ambiguousBlockValue() {\n    // We're being a bit cheeky and reusing the options value from the prior exec\n    var blockHelperMissing = this.aliasable('container.hooks.blockHelperMissing'),\n      params = [this.contextName(0)];\n    this.setupHelperArgs('', 0, params, true);\n    this.flushInline();\n    var current = this.topStack();\n    params.splice(1, 0, current);\n    this.pushSource(['if (!', this.lastHelper, ') { ', current, ' = ', this.source.functionCall(blockHelperMissing, 'call', params), '}']);\n  },\n  // [appendContent]\n  //\n  // On stack, before: ...\n  // On stack, after: ...\n  //\n  // Appends the string value of `content` to the current buffer\n  appendContent: function appendContent(content) {\n    if (this.pendingContent) {\n      content = this.pendingContent + content;\n    } else {\n      this.pendingLocation = this.source.currentLocation;\n    }\n    this.pendingContent = content;\n  },\n  // [append]\n  //\n  // On stack, before: value, ...\n  // On stack, after: ...\n  //\n  // Coerces `value` to a String and appends it to the current buffer.\n  //\n  // If `value` is truthy, or 0, it is coerced into a string and appended\n  // Otherwise, the empty string is appended\n  append: function append() {\n    if (this.isInline()) {\n      this.replaceStack(function (current) {\n        return [' != null ? ', current, ' : \"\"'];\n      });\n      this.pushSource(this.appendToBuffer(this.popStack()));\n    } else {\n      var local = this.popStack();\n      this.pushSource(['if (', local, ' != null) { ', this.appendToBuffer(local, undefined, true), ' }']);\n      if (this.environment.isSimple) {\n        this.pushSource(['else { ', this.appendToBuffer(\"''\", undefined, true), ' }']);\n      }\n    }\n  },\n  // [appendEscaped]\n  //\n  // On stack, before: value, ...\n  // On stack, after: ...\n  //\n  // Escape `value` and append it to the buffer\n  appendEscaped: function appendEscaped() {\n    this.pushSource(this.appendToBuffer([this.aliasable('container.escapeExpression'), '(', this.popStack(), ')']));\n  },\n  // [getContext]\n  //\n  // On stack, before: ...\n  // On stack, after: ...\n  // Compiler value, after: lastContext=depth\n  //\n  // Set the value of the `lastContext` compiler value to the depth\n  getContext: function getContext(depth) {\n    this.lastContext = depth;\n  },\n  // [pushContext]\n  //\n  // On stack, before: ...\n  // On stack, after: currentContext, ...\n  //\n  // Pushes the value of the current context onto the stack.\n  pushContext: function pushContext() {\n    this.pushStackLiteral(this.contextName(this.lastContext));\n  },\n  // [lookupOnContext]\n  //\n  // On stack, before: ...\n  // On stack, after: currentContext[name], ...\n  //\n  // Looks up the value of `name` on the current context and pushes\n  // it onto the stack.\n  lookupOnContext: function lookupOnContext(parts, falsy, strict, scoped) {\n    var i = 0;\n    if (!scoped && this.options.compat && !this.lastContext) {\n      // The depthed query is expected to handle the undefined logic for the root level that\n      // is implemented below, so we evaluate that directly in compat mode\n      this.push(this.depthedLookup(parts[i++]));\n    } else {\n      this.pushContext();\n    }\n    this.resolvePath('context', parts, i, falsy, strict);\n  },\n  // [lookupBlockParam]\n  //\n  // On stack, before: ...\n  // On stack, after: blockParam[name], ...\n  //\n  // Looks up the value of `parts` on the given block param and pushes\n  // it onto the stack.\n  lookupBlockParam: function lookupBlockParam(blockParamId, parts) {\n    this.useBlockParams = true;\n    this.push(['blockParams[', blockParamId[0], '][', blockParamId[1], ']']);\n    this.resolvePath('context', parts, 1);\n  },\n  // [lookupData]\n  //\n  // On stack, before: ...\n  // On stack, after: data, ...\n  //\n  // Push the data lookup operator\n  lookupData: function lookupData(depth, parts, strict) {\n    if (!depth) {\n      this.pushStackLiteral('data');\n    } else {\n      this.pushStackLiteral('container.data(data, ' + depth + ')');\n    }\n    this.resolvePath('data', parts, 0, true, strict);\n  },\n  resolvePath: function resolvePath(type, parts, i, falsy, strict) {\n    // istanbul ignore next\n\n    var _this2 = this;\n    if (this.options.strict || this.options.assumeObjects) {\n      this.push(strictLookup(this.options.strict && strict, this, parts, i, type));\n      return;\n    }\n    var len = parts.length;\n    for (; i < len; i++) {\n      /* eslint-disable no-loop-func */\n      this.replaceStack(function (current) {\n        var lookup = _this2.nameLookup(current, parts[i], type);\n        // We want to ensure that zero and false are handled properly if the context (falsy flag)\n        // needs to have the special handling for these values.\n        if (!falsy) {\n          return [' != null ? ', lookup, ' : ', current];\n        } else {\n          // Otherwise we can use generic falsy handling\n          return [' && ', lookup];\n        }\n      });\n      /* eslint-enable no-loop-func */\n    }\n  },\n  // [resolvePossibleLambda]\n  //\n  // On stack, before: value, ...\n  // On stack, after: resolved value, ...\n  //\n  // If the `value` is a lambda, replace it on the stack by\n  // the return value of the lambda\n  resolvePossibleLambda: function resolvePossibleLambda() {\n    this.push([this.aliasable('container.lambda'), '(', this.popStack(), ', ', this.contextName(0), ')']);\n  },\n  // [pushStringParam]\n  //\n  // On stack, before: ...\n  // On stack, after: string, currentContext, ...\n  //\n  // This opcode is designed for use in string mode, which\n  // provides the string value of a parameter along with its\n  // depth rather than resolving it immediately.\n  pushStringParam: function pushStringParam(string, type) {\n    this.pushContext();\n    this.pushString(type);\n\n    // If it's a subexpression, the string result\n    // will be pushed after this opcode.\n    if (type !== 'SubExpression') {\n      if (typeof string === 'string') {\n        this.pushString(string);\n      } else {\n        this.pushStackLiteral(string);\n      }\n    }\n  },\n  emptyHash: function emptyHash(omitEmpty) {\n    if (this.trackIds) {\n      this.push('{}'); // hashIds\n    }\n    if (this.stringParams) {\n      this.push('{}'); // hashContexts\n      this.push('{}'); // hashTypes\n    }\n    this.pushStackLiteral(omitEmpty ? 'undefined' : '{}');\n  },\n  pushHash: function pushHash() {\n    if (this.hash) {\n      this.hashes.push(this.hash);\n    }\n    this.hash = {\n      values: {},\n      types: [],\n      contexts: [],\n      ids: []\n    };\n  },\n  popHash: function popHash() {\n    var hash = this.hash;\n    this.hash = this.hashes.pop();\n    if (this.trackIds) {\n      this.push(this.objectLiteral(hash.ids));\n    }\n    if (this.stringParams) {\n      this.push(this.objectLiteral(hash.contexts));\n      this.push(this.objectLiteral(hash.types));\n    }\n    this.push(this.objectLiteral(hash.values));\n  },\n  // [pushString]\n  //\n  // On stack, before: ...\n  // On stack, after: quotedString(string), ...\n  //\n  // Push a quoted version of `string` onto the stack\n  pushString: function pushString(string) {\n    this.pushStackLiteral(this.quotedString(string));\n  },\n  // [pushLiteral]\n  //\n  // On stack, before: ...\n  // On stack, after: value, ...\n  //\n  // Pushes a value onto the stack. This operation prevents\n  // the compiler from creating a temporary variable to hold\n  // it.\n  pushLiteral: function pushLiteral(value) {\n    this.pushStackLiteral(value);\n  },\n  // [pushProgram]\n  //\n  // On stack, before: ...\n  // On stack, after: program(guid), ...\n  //\n  // Push a program expression onto the stack. This takes\n  // a compile-time guid and converts it into a runtime-accessible\n  // expression.\n  pushProgram: function pushProgram(guid) {\n    if (guid != null) {\n      this.pushStackLiteral(this.programExpression(guid));\n    } else {\n      this.pushStackLiteral(null);\n    }\n  },\n  // [registerDecorator]\n  //\n  // On stack, before: hash, program, params..., ...\n  // On stack, after: ...\n  //\n  // Pops off the decorator's parameters, invokes the decorator,\n  // and inserts the decorator into the decorators list.\n  registerDecorator: function registerDecorator(paramSize, name) {\n    var foundDecorator = this.nameLookup('decorators', name, 'decorator'),\n      options = this.setupHelperArgs(name, paramSize);\n    this.decorators.push(['fn = ', this.decorators.functionCall(foundDecorator, '', ['fn', 'props', 'container', options]), ' || fn;']);\n  },\n  // [invokeHelper]\n  //\n  // On stack, before: hash, inverse, program, params..., ...\n  // On stack, after: result of helper invocation\n  //\n  // Pops off the helper's parameters, invokes the helper,\n  // and pushes the helper's return value onto the stack.\n  //\n  // If the helper is not found, `helperMissing` is called.\n  invokeHelper: function invokeHelper(paramSize, name, isSimple) {\n    var nonHelper = this.popStack(),\n      helper = this.setupHelper(paramSize, name);\n    var possibleFunctionCalls = [];\n    if (isSimple) {\n      // direct call to helper\n      possibleFunctionCalls.push(helper.name);\n    }\n    // call a function from the input object\n    possibleFunctionCalls.push(nonHelper);\n    if (!this.options.strict) {\n      possibleFunctionCalls.push(this.aliasable('container.hooks.helperMissing'));\n    }\n    var functionLookupCode = ['(', this.itemsSeparatedBy(possibleFunctionCalls, '||'), ')'];\n    var functionCall = this.source.functionCall(functionLookupCode, 'call', helper.callParams);\n    this.push(functionCall);\n  },\n  itemsSeparatedBy: function itemsSeparatedBy(items, separator) {\n    var result = [];\n    result.push(items[0]);\n    for (var i = 1; i < items.length; i++) {\n      result.push(separator, items[i]);\n    }\n    return result;\n  },\n  // [invokeKnownHelper]\n  //\n  // On stack, before: hash, inverse, program, params..., ...\n  // On stack, after: result of helper invocation\n  //\n  // This operation is used when the helper is known to exist,\n  // so a `helperMissing` fallback is not required.\n  invokeKnownHelper: function invokeKnownHelper(paramSize, name) {\n    var helper = this.setupHelper(paramSize, name);\n    this.push(this.source.functionCall(helper.name, 'call', helper.callParams));\n  },\n  // [invokeAmbiguous]\n  //\n  // On stack, before: hash, inverse, program, params..., ...\n  // On stack, after: result of disambiguation\n  //\n  // This operation is used when an expression like `{{foo}}`\n  // is provided, but we don't know at compile-time whether it\n  // is a helper or a path.\n  //\n  // This operation emits more code than the other options,\n  // and can be avoided by passing the `knownHelpers` and\n  // `knownHelpersOnly` flags at compile-time.\n  invokeAmbiguous: function invokeAmbiguous(name, helperCall) {\n    this.useRegister('helper');\n    var nonHelper = this.popStack();\n    this.emptyHash();\n    var helper = this.setupHelper(0, name, helperCall);\n    var helperName = this.lastHelper = this.nameLookup('helpers', name, 'helper');\n    var lookup = ['(', '(helper = ', helperName, ' || ', nonHelper, ')'];\n    if (!this.options.strict) {\n      lookup[0] = '(helper = ';\n      lookup.push(' != null ? helper : ', this.aliasable('container.hooks.helperMissing'));\n    }\n    this.push(['(', lookup, helper.paramsInit ? ['),(', helper.paramsInit] : [], '),', '(typeof helper === ', this.aliasable('\"function\"'), ' ? ', this.source.functionCall('helper', 'call', helper.callParams), ' : helper))']);\n  },\n  // [invokePartial]\n  //\n  // On stack, before: context, ...\n  // On stack after: result of partial invocation\n  //\n  // This operation pops off a context, invokes a partial with that context,\n  // and pushes the result of the invocation back.\n  invokePartial: function invokePartial(isDynamic, name, indent) {\n    var params = [],\n      options = this.setupParams(name, 1, params);\n    if (isDynamic) {\n      name = this.popStack();\n      delete options.name;\n    }\n    if (indent) {\n      options.indent = JSON.stringify(indent);\n    }\n    options.helpers = 'helpers';\n    options.partials = 'partials';\n    options.decorators = 'container.decorators';\n    if (!isDynamic) {\n      params.unshift(this.nameLookup('partials', name, 'partial'));\n    } else {\n      params.unshift(name);\n    }\n    if (this.options.compat) {\n      options.depths = 'depths';\n    }\n    options = this.objectLiteral(options);\n    params.push(options);\n    this.push(this.source.functionCall('container.invokePartial', '', params));\n  },\n  // [assignToHash]\n  //\n  // On stack, before: value, ..., hash, ...\n  // On stack, after: ..., hash, ...\n  //\n  // Pops a value off the stack and assigns it to the current hash\n  assignToHash: function assignToHash(key) {\n    var value = this.popStack(),\n      context = undefined,\n      type = undefined,\n      id = undefined;\n    if (this.trackIds) {\n      id = this.popStack();\n    }\n    if (this.stringParams) {\n      type = this.popStack();\n      context = this.popStack();\n    }\n    var hash = this.hash;\n    if (context) {\n      hash.contexts[key] = context;\n    }\n    if (type) {\n      hash.types[key] = type;\n    }\n    if (id) {\n      hash.ids[key] = id;\n    }\n    hash.values[key] = value;\n  },\n  pushId: function pushId(type, name, child) {\n    if (type === 'BlockParam') {\n      this.pushStackLiteral('blockParams[' + name[0] + '].path[' + name[1] + ']' + (child ? ' + ' + JSON.stringify('.' + child) : ''));\n    } else if (type === 'PathExpression') {\n      this.pushString(name);\n    } else if (type === 'SubExpression') {\n      this.pushStackLiteral('true');\n    } else {\n      this.pushStackLiteral('null');\n    }\n  },\n  // HELPERS\n\n  compiler: JavaScriptCompiler,\n  compileChildren: function compileChildren(environment, options) {\n    var children = environment.children,\n      child = undefined,\n      compiler = undefined;\n    for (var i = 0, l = children.length; i < l; i++) {\n      child = children[i];\n      compiler = new this.compiler(); // eslint-disable-line new-cap\n\n      var existing = this.matchExistingProgram(child);\n      if (existing == null) {\n        this.context.programs.push(''); // Placeholder to prevent name conflicts for nested children\n        var index = this.context.programs.length;\n        child.index = index;\n        child.name = 'program' + index;\n        this.context.programs[index] = compiler.compile(child, options, this.context, !this.precompile);\n        this.context.decorators[index] = compiler.decorators;\n        this.context.environments[index] = child;\n        this.useDepths = this.useDepths || compiler.useDepths;\n        this.useBlockParams = this.useBlockParams || compiler.useBlockParams;\n        child.useDepths = this.useDepths;\n        child.useBlockParams = this.useBlockParams;\n      } else {\n        child.index = existing.index;\n        child.name = 'program' + existing.index;\n        this.useDepths = this.useDepths || existing.useDepths;\n        this.useBlockParams = this.useBlockParams || existing.useBlockParams;\n      }\n    }\n  },\n  matchExistingProgram: function matchExistingProgram(child) {\n    for (var i = 0, len = this.context.environments.length; i < len; i++) {\n      var environment = this.context.environments[i];\n      if (environment && environment.equals(child)) {\n        return environment;\n      }\n    }\n  },\n  programExpression: function programExpression(guid) {\n    var child = this.environment.children[guid],\n      programParams = [child.index, 'data', child.blockParams];\n    if (this.useBlockParams || this.useDepths) {\n      programParams.push('blockParams');\n    }\n    if (this.useDepths) {\n      programParams.push('depths');\n    }\n    return 'container.program(' + programParams.join(', ') + ')';\n  },\n  useRegister: function useRegister(name) {\n    if (!this.registers[name]) {\n      this.registers[name] = true;\n      this.registers.list.push(name);\n    }\n  },\n  push: function push(expr) {\n    if (!(expr instanceof Literal)) {\n      expr = this.source.wrap(expr);\n    }\n    this.inlineStack.push(expr);\n    return expr;\n  },\n  pushStackLiteral: function pushStackLiteral(item) {\n    this.push(new Literal(item));\n  },\n  pushSource: function pushSource(source) {\n    if (this.pendingContent) {\n      this.source.push(this.appendToBuffer(this.source.quotedString(this.pendingContent), this.pendingLocation));\n      this.pendingContent = undefined;\n    }\n    if (source) {\n      this.source.push(source);\n    }\n  },\n  replaceStack: function replaceStack(callback) {\n    var prefix = ['('],\n      stack = undefined,\n      createdStack = undefined,\n      usedLiteral = undefined;\n\n    /* istanbul ignore next */\n    if (!this.isInline()) {\n      throw new _exception2['default']('replaceStack on non-inline');\n    }\n\n    // We want to merge the inline statement into the replacement statement via ','\n    var top = this.popStack(true);\n    if (top instanceof Literal) {\n      // Literals do not need to be inlined\n      stack = [top.value];\n      prefix = ['(', stack];\n      usedLiteral = true;\n    } else {\n      // Get or create the current stack name for use by the inline\n      createdStack = true;\n      var _name = this.incrStack();\n      prefix = ['((', this.push(_name), ' = ', top, ')'];\n      stack = this.topStack();\n    }\n    var item = callback.call(this, stack);\n    if (!usedLiteral) {\n      this.popStack();\n    }\n    if (createdStack) {\n      this.stackSlot--;\n    }\n    this.push(prefix.concat(item, ')'));\n  },\n  incrStack: function incrStack() {\n    this.stackSlot++;\n    if (this.stackSlot > this.stackVars.length) {\n      this.stackVars.push('stack' + this.stackSlot);\n    }\n    return this.topStackName();\n  },\n  topStackName: function topStackName() {\n    return 'stack' + this.stackSlot;\n  },\n  flushInline: function flushInline() {\n    var inlineStack = this.inlineStack;\n    this.inlineStack = [];\n    for (var i = 0, len = inlineStack.length; i < len; i++) {\n      var entry = inlineStack[i];\n      /* istanbul ignore if */\n      if (entry instanceof Literal) {\n        this.compileStack.push(entry);\n      } else {\n        var stack = this.incrStack();\n        this.pushSource([stack, ' = ', entry, ';']);\n        this.compileStack.push(stack);\n      }\n    }\n  },\n  isInline: function isInline() {\n    return this.inlineStack.length;\n  },\n  popStack: function popStack(wrapped) {\n    var inline = this.isInline(),\n      item = (inline ? this.inlineStack : this.compileStack).pop();\n    if (!wrapped && item instanceof Literal) {\n      return item.value;\n    } else {\n      if (!inline) {\n        /* istanbul ignore next */\n        if (!this.stackSlot) {\n          throw new _exception2['default']('Invalid stack pop');\n        }\n        this.stackSlot--;\n      }\n      return item;\n    }\n  },\n  topStack: function topStack() {\n    var stack = this.isInline() ? this.inlineStack : this.compileStack,\n      item = stack[stack.length - 1];\n\n    /* istanbul ignore if */\n    if (item instanceof Literal) {\n      return item.value;\n    } else {\n      return item;\n    }\n  },\n  contextName: function contextName(context) {\n    if (this.useDepths && context) {\n      return 'depths[' + context + ']';\n    } else {\n      return 'depth' + context;\n    }\n  },\n  quotedString: function quotedString(str) {\n    return this.source.quotedString(str);\n  },\n  objectLiteral: function objectLiteral(obj) {\n    return this.source.objectLiteral(obj);\n  },\n  aliasable: function aliasable(name) {\n    var ret = this.aliases[name];\n    if (ret) {\n      ret.referenceCount++;\n      return ret;\n    }\n    ret = this.aliases[name] = this.source.wrap(name);\n    ret.aliasable = true;\n    ret.referenceCount = 1;\n    return ret;\n  },\n  setupHelper: function setupHelper(paramSize, name, blockHelper) {\n    var params = [],\n      paramsInit = this.setupHelperArgs(name, paramSize, params, blockHelper);\n    var foundHelper = this.nameLookup('helpers', name, 'helper'),\n      callContext = this.aliasable(this.contextName(0) + ' != null ? ' + this.contextName(0) + ' : (container.nullContext || {})');\n    return {\n      params: params,\n      paramsInit: paramsInit,\n      name: foundHelper,\n      callParams: [callContext].concat(params)\n    };\n  },\n  setupParams: function setupParams(helper, paramSize, params) {\n    var options = {},\n      contexts = [],\n      types = [],\n      ids = [],\n      objectArgs = !params,\n      param = undefined;\n    if (objectArgs) {\n      params = [];\n    }\n    options.name = this.quotedString(helper);\n    options.hash = this.popStack();\n    if (this.trackIds) {\n      options.hashIds = this.popStack();\n    }\n    if (this.stringParams) {\n      options.hashTypes = this.popStack();\n      options.hashContexts = this.popStack();\n    }\n    var inverse = this.popStack(),\n      program = this.popStack();\n\n    // Avoid setting fn and inverse if neither are set. This allows\n    // helpers to do a check for `if (options.fn)`\n    if (program || inverse) {\n      options.fn = program || 'container.noop';\n      options.inverse = inverse || 'container.noop';\n    }\n\n    // The parameters go on to the stack in order (making sure that they are evaluated in order)\n    // so we need to pop them off the stack in reverse order\n    var i = paramSize;\n    while (i--) {\n      param = this.popStack();\n      params[i] = param;\n      if (this.trackIds) {\n        ids[i] = this.popStack();\n      }\n      if (this.stringParams) {\n        types[i] = this.popStack();\n        contexts[i] = this.popStack();\n      }\n    }\n    if (objectArgs) {\n      options.args = this.source.generateArray(params);\n    }\n    if (this.trackIds) {\n      options.ids = this.source.generateArray(ids);\n    }\n    if (this.stringParams) {\n      options.types = this.source.generateArray(types);\n      options.contexts = this.source.generateArray(contexts);\n    }\n    if (this.options.data) {\n      options.data = 'data';\n    }\n    if (this.useBlockParams) {\n      options.blockParams = 'blockParams';\n    }\n    return options;\n  },\n  setupHelperArgs: function setupHelperArgs(helper, paramSize, params, useRegister) {\n    var options = this.setupParams(helper, paramSize, params);\n    options.loc = JSON.stringify(this.source.currentLocation);\n    options = this.objectLiteral(options);\n    if (useRegister) {\n      this.useRegister('options');\n      params.push('options');\n      return ['options=', options];\n    } else if (params) {\n      params.push(options);\n      return '';\n    } else {\n      return options;\n    }\n  }\n};\n(function () {\n  var reservedWords = ('break else new var' + ' case finally return void' + ' catch for switch while' + ' continue function this with' + ' default if throw' + ' delete in try' + ' do instanceof typeof' + ' abstract enum int short' + ' boolean export interface static' + ' byte extends long super' + ' char final native synchronized' + ' class float package throws' + ' const goto private transient' + ' debugger implements protected volatile' + ' double import public let yield await' + ' null true false').split(' ');\n  var compilerWords = JavaScriptCompiler.RESERVED_WORDS = {};\n  for (var i = 0, l = reservedWords.length; i < l; i++) {\n    compilerWords[reservedWords[i]] = true;\n  }\n})();\n\n/**\n * @deprecated May be removed in the next major version\n */\nJavaScriptCompiler.isValidJavaScriptVariableName = function (name) {\n  return !JavaScriptCompiler.RESERVED_WORDS[name] && /^[a-zA-Z_$][0-9a-zA-Z_$]*$/.test(name);\n};\nfunction strictLookup(requireTerminal, compiler, parts, i, type) {\n  var stack = compiler.popStack(),\n    len = parts.length;\n  if (requireTerminal) {\n    len--;\n  }\n  for (; i < len; i++) {\n    stack = compiler.nameLookup(stack, parts[i], type);\n  }\n  if (requireTerminal) {\n    return [compiler.aliasable('container.strict'), '(', stack, ', ', compiler.quotedString(parts[i]), ', ', JSON.stringify(compiler.source.currentLocation), ' )'];\n  } else {\n    return stack;\n  }\n}\nexports['default'] = JavaScriptCompiler;\nmodule.exports = exports['default'];","map":{"version":3,"names":["Literal","value","JavaScriptCompiler","prototype","nameLookup","parent","name","internalNameLookup","depthedLookup","aliasable","JSON","stringify","compilerInfo","revision","_base","COMPILER_REVISION","versions","REVISION_CHANGES","appendToBuffer","source","location","explicit","_utils","isArray","wrap","environment","isSimple","initializeBuffer","quotedString","lookupPropertyFunctionIsUsed","compile","options","context","asObject","stringParams","trackIds","precompile","isChild","decorators","programs","environments","preamble","stackSlot","stackVars","aliases","registers","list","hashes","compileStack","inlineStack","blockParams","compileChildren","useDepths","useDecorators","compat","useBlockParams","opcodes","opcode","undefined","firstLoc","i","l","length","currentLocation","loc","apply","args","pushSource","_exception2","isEmpty","prepend","lookupPropertyFunctionVarDeclaration","push","Function","merge","fn","createFunctionContext","ret","compiler","main","main_d","_context","usePartial","data","useData","start","line","column","objectLiteral","srcName","toStringWithSourceMap","file","destName","map","toString","compilerOptions","lastContext","_codeGen2","varDeclarations","locals","concat","join","aliasCount","Object","keys","forEach","alias","node","_this","children","referenceCount","params","mergeSource","appendOnly","forceBuffer","appendFirst","sourceSeen","bufferStart","bufferEnd","each","add","substring","trim","blockValue","blockHelperMissing","contextName","setupHelperArgs","blockName","popStack","splice","functionCall","ambiguousBlockValue","flushInline","current","topStack","lastHelper","appendContent","content","pendingContent","pendingLocation","append","isInline","replaceStack","local","appendEscaped","getContext","depth","pushContext","pushStackLiteral","lookupOnContext","parts","falsy","strict","scoped","resolvePath","lookupBlockParam","blockParamId","lookupData","type","assumeObjects","strictLookup","len","lookup","_this2","resolvePossibleLambda","pushStringParam","string","pushString","emptyHash","omitEmpty","pushHash","hash","values","types","contexts","ids","popHash","pop","pushLiteral","pushProgram","guid","programExpression","registerDecorator","paramSize","foundDecorator","invokeHelper","nonHelper","helper","setupHelper","possibleFunctionCalls","functionLookupCode","itemsSeparatedBy","callParams","items","separator","result","invokeKnownHelper","invokeAmbiguous","helperCall","useRegister","helperName","paramsInit","invokePartial","isDynamic","indent","setupParams","helpers","partials","unshift","depths","assignToHash","key","id","pushId","child","existing","matchExistingProgram","index","equals","programParams","expr","item","callback","prefix","stack","createdStack","usedLiteral","top","_name","incrStack","call","topStackName","entry","wrapped","inline","str","obj","blockHelper","foundHelper","callContext","objectArgs","param","hashIds","hashTypes","hashContexts","inverse","program","generateArray","reservedWords","split","compilerWords","RESERVED_WORDS","isValidJavaScriptVariableName","test","requireTerminal"],"sources":["/home/kaushik/Documents/Projects/TemplateFillerReact/node_modules/handlebars/lib/handlebars/compiler/javascript-compiler.js"],"sourcesContent":["import { COMPILER_REVISION, REVISION_CHANGES } from '../base';\nimport Exception from '../exception';\nimport { isArray } from '../utils';\nimport CodeGen from './code-gen';\n\nfunction Literal(value) {\n  this.value = value;\n}\n\nfunction JavaScriptCompiler() {}\n\nJavaScriptCompiler.prototype = {\n  // PUBLIC API: You can override these methods in a subclass to provide\n  // alternative compiled forms for name lookup and buffering semantics\n  nameLookup: function(parent, name /*,  type */) {\n    return this.internalNameLookup(parent, name);\n  },\n  depthedLookup: function(name) {\n    return [\n      this.aliasable('container.lookup'),\n      '(depths, ',\n      JSON.stringify(name),\n      ')'\n    ];\n  },\n\n  compilerInfo: function() {\n    const revision = COMPILER_REVISION,\n      versions = REVISION_CHANGES[revision];\n    return [revision, versions];\n  },\n\n  appendToBuffer: function(source, location, explicit) {\n    // Force a source as this simplifies the merge logic.\n    if (!isArray(source)) {\n      source = [source];\n    }\n    source = this.source.wrap(source, location);\n\n    if (this.environment.isSimple) {\n      return ['return ', source, ';'];\n    } else if (explicit) {\n      // This is a case where the buffer operation occurs as a child of another\n      // construct, generally braces. We have to explicitly output these buffer\n      // operations to ensure that the emitted code goes in the correct location.\n      return ['buffer += ', source, ';'];\n    } else {\n      source.appendToBuffer = true;\n      return source;\n    }\n  },\n\n  initializeBuffer: function() {\n    return this.quotedString('');\n  },\n  // END PUBLIC API\n  internalNameLookup: function(parent, name) {\n    this.lookupPropertyFunctionIsUsed = true;\n    return ['lookupProperty(', parent, ',', JSON.stringify(name), ')'];\n  },\n\n  lookupPropertyFunctionIsUsed: false,\n\n  compile: function(environment, options, context, asObject) {\n    this.environment = environment;\n    this.options = options;\n    this.stringParams = this.options.stringParams;\n    this.trackIds = this.options.trackIds;\n    this.precompile = !asObject;\n\n    this.name = this.environment.name;\n    this.isChild = !!context;\n    this.context = context || {\n      decorators: [],\n      programs: [],\n      environments: []\n    };\n\n    this.preamble();\n\n    this.stackSlot = 0;\n    this.stackVars = [];\n    this.aliases = {};\n    this.registers = { list: [] };\n    this.hashes = [];\n    this.compileStack = [];\n    this.inlineStack = [];\n    this.blockParams = [];\n\n    this.compileChildren(environment, options);\n\n    this.useDepths =\n      this.useDepths ||\n      environment.useDepths ||\n      environment.useDecorators ||\n      this.options.compat;\n    this.useBlockParams = this.useBlockParams || environment.useBlockParams;\n\n    let opcodes = environment.opcodes,\n      opcode,\n      firstLoc,\n      i,\n      l;\n\n    for (i = 0, l = opcodes.length; i < l; i++) {\n      opcode = opcodes[i];\n\n      this.source.currentLocation = opcode.loc;\n      firstLoc = firstLoc || opcode.loc;\n      this[opcode.opcode].apply(this, opcode.args);\n    }\n\n    // Flush any trailing content that might be pending.\n    this.source.currentLocation = firstLoc;\n    this.pushSource('');\n\n    /* istanbul ignore next */\n    if (this.stackSlot || this.inlineStack.length || this.compileStack.length) {\n      throw new Exception('Compile completed with content left on stack');\n    }\n\n    if (!this.decorators.isEmpty()) {\n      this.useDecorators = true;\n\n      this.decorators.prepend([\n        'var decorators = container.decorators, ',\n        this.lookupPropertyFunctionVarDeclaration(),\n        ';\\n'\n      ]);\n      this.decorators.push('return fn;');\n\n      if (asObject) {\n        this.decorators = Function.apply(this, [\n          'fn',\n          'props',\n          'container',\n          'depth0',\n          'data',\n          'blockParams',\n          'depths',\n          this.decorators.merge()\n        ]);\n      } else {\n        this.decorators.prepend(\n          'function(fn, props, container, depth0, data, blockParams, depths) {\\n'\n        );\n        this.decorators.push('}\\n');\n        this.decorators = this.decorators.merge();\n      }\n    } else {\n      this.decorators = undefined;\n    }\n\n    let fn = this.createFunctionContext(asObject);\n    if (!this.isChild) {\n      let ret = {\n        compiler: this.compilerInfo(),\n        main: fn\n      };\n\n      if (this.decorators) {\n        ret.main_d = this.decorators; // eslint-disable-line camelcase\n        ret.useDecorators = true;\n      }\n\n      let { programs, decorators } = this.context;\n      for (i = 0, l = programs.length; i < l; i++) {\n        if (programs[i]) {\n          ret[i] = programs[i];\n          if (decorators[i]) {\n            ret[i + '_d'] = decorators[i];\n            ret.useDecorators = true;\n          }\n        }\n      }\n\n      if (this.environment.usePartial) {\n        ret.usePartial = true;\n      }\n      if (this.options.data) {\n        ret.useData = true;\n      }\n      if (this.useDepths) {\n        ret.useDepths = true;\n      }\n      if (this.useBlockParams) {\n        ret.useBlockParams = true;\n      }\n      if (this.options.compat) {\n        ret.compat = true;\n      }\n\n      if (!asObject) {\n        ret.compiler = JSON.stringify(ret.compiler);\n\n        this.source.currentLocation = { start: { line: 1, column: 0 } };\n        ret = this.objectLiteral(ret);\n\n        if (options.srcName) {\n          ret = ret.toStringWithSourceMap({ file: options.destName });\n          ret.map = ret.map && ret.map.toString();\n        } else {\n          ret = ret.toString();\n        }\n      } else {\n        ret.compilerOptions = this.options;\n      }\n\n      return ret;\n    } else {\n      return fn;\n    }\n  },\n\n  preamble: function() {\n    // track the last context pushed into place to allow skipping the\n    // getContext opcode when it would be a noop\n    this.lastContext = 0;\n    this.source = new CodeGen(this.options.srcName);\n    this.decorators = new CodeGen(this.options.srcName);\n  },\n\n  createFunctionContext: function(asObject) {\n    let varDeclarations = '';\n\n    let locals = this.stackVars.concat(this.registers.list);\n    if (locals.length > 0) {\n      varDeclarations += ', ' + locals.join(', ');\n    }\n\n    // Generate minimizer alias mappings\n    //\n    // When using true SourceNodes, this will update all references to the given alias\n    // as the source nodes are reused in situ. For the non-source node compilation mode,\n    // aliases will not be used, but this case is already being run on the client and\n    // we aren't concern about minimizing the template size.\n    let aliasCount = 0;\n    Object.keys(this.aliases).forEach(alias => {\n      let node = this.aliases[alias];\n      if (node.children && node.referenceCount > 1) {\n        varDeclarations += ', alias' + ++aliasCount + '=' + alias;\n        node.children[0] = 'alias' + aliasCount;\n      }\n    });\n\n    if (this.lookupPropertyFunctionIsUsed) {\n      varDeclarations += ', ' + this.lookupPropertyFunctionVarDeclaration();\n    }\n\n    let params = ['container', 'depth0', 'helpers', 'partials', 'data'];\n\n    if (this.useBlockParams || this.useDepths) {\n      params.push('blockParams');\n    }\n    if (this.useDepths) {\n      params.push('depths');\n    }\n\n    // Perform a second pass over the output to merge content when possible\n    let source = this.mergeSource(varDeclarations);\n\n    if (asObject) {\n      params.push(source);\n\n      return Function.apply(this, params);\n    } else {\n      return this.source.wrap([\n        'function(',\n        params.join(','),\n        ') {\\n  ',\n        source,\n        '}'\n      ]);\n    }\n  },\n  mergeSource: function(varDeclarations) {\n    let isSimple = this.environment.isSimple,\n      appendOnly = !this.forceBuffer,\n      appendFirst,\n      sourceSeen,\n      bufferStart,\n      bufferEnd;\n    this.source.each(line => {\n      if (line.appendToBuffer) {\n        if (bufferStart) {\n          line.prepend('  + ');\n        } else {\n          bufferStart = line;\n        }\n        bufferEnd = line;\n      } else {\n        if (bufferStart) {\n          if (!sourceSeen) {\n            appendFirst = true;\n          } else {\n            bufferStart.prepend('buffer += ');\n          }\n          bufferEnd.add(';');\n          bufferStart = bufferEnd = undefined;\n        }\n\n        sourceSeen = true;\n        if (!isSimple) {\n          appendOnly = false;\n        }\n      }\n    });\n\n    if (appendOnly) {\n      if (bufferStart) {\n        bufferStart.prepend('return ');\n        bufferEnd.add(';');\n      } else if (!sourceSeen) {\n        this.source.push('return \"\";');\n      }\n    } else {\n      varDeclarations +=\n        ', buffer = ' + (appendFirst ? '' : this.initializeBuffer());\n\n      if (bufferStart) {\n        bufferStart.prepend('return buffer + ');\n        bufferEnd.add(';');\n      } else {\n        this.source.push('return buffer;');\n      }\n    }\n\n    if (varDeclarations) {\n      this.source.prepend(\n        'var ' + varDeclarations.substring(2) + (appendFirst ? '' : ';\\n')\n      );\n    }\n\n    return this.source.merge();\n  },\n\n  lookupPropertyFunctionVarDeclaration: function() {\n    return `\n      lookupProperty = container.lookupProperty || function(parent, propertyName) {\n        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {\n          return parent[propertyName];\n        }\n        return undefined\n    }\n    `.trim();\n  },\n\n  // [blockValue]\n  //\n  // On stack, before: hash, inverse, program, value\n  // On stack, after: return value of blockHelperMissing\n  //\n  // The purpose of this opcode is to take a block of the form\n  // `{{#this.foo}}...{{/this.foo}}`, resolve the value of `foo`, and\n  // replace it on the stack with the result of properly\n  // invoking blockHelperMissing.\n  blockValue: function(name) {\n    let blockHelperMissing = this.aliasable(\n        'container.hooks.blockHelperMissing'\n      ),\n      params = [this.contextName(0)];\n    this.setupHelperArgs(name, 0, params);\n\n    let blockName = this.popStack();\n    params.splice(1, 0, blockName);\n\n    this.push(this.source.functionCall(blockHelperMissing, 'call', params));\n  },\n\n  // [ambiguousBlockValue]\n  //\n  // On stack, before: hash, inverse, program, value\n  // Compiler value, before: lastHelper=value of last found helper, if any\n  // On stack, after, if no lastHelper: same as [blockValue]\n  // On stack, after, if lastHelper: value\n  ambiguousBlockValue: function() {\n    // We're being a bit cheeky and reusing the options value from the prior exec\n    let blockHelperMissing = this.aliasable(\n        'container.hooks.blockHelperMissing'\n      ),\n      params = [this.contextName(0)];\n    this.setupHelperArgs('', 0, params, true);\n\n    this.flushInline();\n\n    let current = this.topStack();\n    params.splice(1, 0, current);\n\n    this.pushSource([\n      'if (!',\n      this.lastHelper,\n      ') { ',\n      current,\n      ' = ',\n      this.source.functionCall(blockHelperMissing, 'call', params),\n      '}'\n    ]);\n  },\n\n  // [appendContent]\n  //\n  // On stack, before: ...\n  // On stack, after: ...\n  //\n  // Appends the string value of `content` to the current buffer\n  appendContent: function(content) {\n    if (this.pendingContent) {\n      content = this.pendingContent + content;\n    } else {\n      this.pendingLocation = this.source.currentLocation;\n    }\n\n    this.pendingContent = content;\n  },\n\n  // [append]\n  //\n  // On stack, before: value, ...\n  // On stack, after: ...\n  //\n  // Coerces `value` to a String and appends it to the current buffer.\n  //\n  // If `value` is truthy, or 0, it is coerced into a string and appended\n  // Otherwise, the empty string is appended\n  append: function() {\n    if (this.isInline()) {\n      this.replaceStack(current => [' != null ? ', current, ' : \"\"']);\n\n      this.pushSource(this.appendToBuffer(this.popStack()));\n    } else {\n      let local = this.popStack();\n      this.pushSource([\n        'if (',\n        local,\n        ' != null) { ',\n        this.appendToBuffer(local, undefined, true),\n        ' }'\n      ]);\n      if (this.environment.isSimple) {\n        this.pushSource([\n          'else { ',\n          this.appendToBuffer(\"''\", undefined, true),\n          ' }'\n        ]);\n      }\n    }\n  },\n\n  // [appendEscaped]\n  //\n  // On stack, before: value, ...\n  // On stack, after: ...\n  //\n  // Escape `value` and append it to the buffer\n  appendEscaped: function() {\n    this.pushSource(\n      this.appendToBuffer([\n        this.aliasable('container.escapeExpression'),\n        '(',\n        this.popStack(),\n        ')'\n      ])\n    );\n  },\n\n  // [getContext]\n  //\n  // On stack, before: ...\n  // On stack, after: ...\n  // Compiler value, after: lastContext=depth\n  //\n  // Set the value of the `lastContext` compiler value to the depth\n  getContext: function(depth) {\n    this.lastContext = depth;\n  },\n\n  // [pushContext]\n  //\n  // On stack, before: ...\n  // On stack, after: currentContext, ...\n  //\n  // Pushes the value of the current context onto the stack.\n  pushContext: function() {\n    this.pushStackLiteral(this.contextName(this.lastContext));\n  },\n\n  // [lookupOnContext]\n  //\n  // On stack, before: ...\n  // On stack, after: currentContext[name], ...\n  //\n  // Looks up the value of `name` on the current context and pushes\n  // it onto the stack.\n  lookupOnContext: function(parts, falsy, strict, scoped) {\n    let i = 0;\n\n    if (!scoped && this.options.compat && !this.lastContext) {\n      // The depthed query is expected to handle the undefined logic for the root level that\n      // is implemented below, so we evaluate that directly in compat mode\n      this.push(this.depthedLookup(parts[i++]));\n    } else {\n      this.pushContext();\n    }\n\n    this.resolvePath('context', parts, i, falsy, strict);\n  },\n\n  // [lookupBlockParam]\n  //\n  // On stack, before: ...\n  // On stack, after: blockParam[name], ...\n  //\n  // Looks up the value of `parts` on the given block param and pushes\n  // it onto the stack.\n  lookupBlockParam: function(blockParamId, parts) {\n    this.useBlockParams = true;\n\n    this.push(['blockParams[', blockParamId[0], '][', blockParamId[1], ']']);\n    this.resolvePath('context', parts, 1);\n  },\n\n  // [lookupData]\n  //\n  // On stack, before: ...\n  // On stack, after: data, ...\n  //\n  // Push the data lookup operator\n  lookupData: function(depth, parts, strict) {\n    if (!depth) {\n      this.pushStackLiteral('data');\n    } else {\n      this.pushStackLiteral('container.data(data, ' + depth + ')');\n    }\n\n    this.resolvePath('data', parts, 0, true, strict);\n  },\n\n  resolvePath: function(type, parts, i, falsy, strict) {\n    if (this.options.strict || this.options.assumeObjects) {\n      this.push(\n        strictLookup(this.options.strict && strict, this, parts, i, type)\n      );\n      return;\n    }\n\n    let len = parts.length;\n    for (; i < len; i++) {\n      /* eslint-disable no-loop-func */\n      this.replaceStack(current => {\n        let lookup = this.nameLookup(current, parts[i], type);\n        // We want to ensure that zero and false are handled properly if the context (falsy flag)\n        // needs to have the special handling for these values.\n        if (!falsy) {\n          return [' != null ? ', lookup, ' : ', current];\n        } else {\n          // Otherwise we can use generic falsy handling\n          return [' && ', lookup];\n        }\n      });\n      /* eslint-enable no-loop-func */\n    }\n  },\n\n  // [resolvePossibleLambda]\n  //\n  // On stack, before: value, ...\n  // On stack, after: resolved value, ...\n  //\n  // If the `value` is a lambda, replace it on the stack by\n  // the return value of the lambda\n  resolvePossibleLambda: function() {\n    this.push([\n      this.aliasable('container.lambda'),\n      '(',\n      this.popStack(),\n      ', ',\n      this.contextName(0),\n      ')'\n    ]);\n  },\n\n  // [pushStringParam]\n  //\n  // On stack, before: ...\n  // On stack, after: string, currentContext, ...\n  //\n  // This opcode is designed for use in string mode, which\n  // provides the string value of a parameter along with its\n  // depth rather than resolving it immediately.\n  pushStringParam: function(string, type) {\n    this.pushContext();\n    this.pushString(type);\n\n    // If it's a subexpression, the string result\n    // will be pushed after this opcode.\n    if (type !== 'SubExpression') {\n      if (typeof string === 'string') {\n        this.pushString(string);\n      } else {\n        this.pushStackLiteral(string);\n      }\n    }\n  },\n\n  emptyHash: function(omitEmpty) {\n    if (this.trackIds) {\n      this.push('{}'); // hashIds\n    }\n    if (this.stringParams) {\n      this.push('{}'); // hashContexts\n      this.push('{}'); // hashTypes\n    }\n    this.pushStackLiteral(omitEmpty ? 'undefined' : '{}');\n  },\n  pushHash: function() {\n    if (this.hash) {\n      this.hashes.push(this.hash);\n    }\n    this.hash = { values: {}, types: [], contexts: [], ids: [] };\n  },\n  popHash: function() {\n    let hash = this.hash;\n    this.hash = this.hashes.pop();\n\n    if (this.trackIds) {\n      this.push(this.objectLiteral(hash.ids));\n    }\n    if (this.stringParams) {\n      this.push(this.objectLiteral(hash.contexts));\n      this.push(this.objectLiteral(hash.types));\n    }\n\n    this.push(this.objectLiteral(hash.values));\n  },\n\n  // [pushString]\n  //\n  // On stack, before: ...\n  // On stack, after: quotedString(string), ...\n  //\n  // Push a quoted version of `string` onto the stack\n  pushString: function(string) {\n    this.pushStackLiteral(this.quotedString(string));\n  },\n\n  // [pushLiteral]\n  //\n  // On stack, before: ...\n  // On stack, after: value, ...\n  //\n  // Pushes a value onto the stack. This operation prevents\n  // the compiler from creating a temporary variable to hold\n  // it.\n  pushLiteral: function(value) {\n    this.pushStackLiteral(value);\n  },\n\n  // [pushProgram]\n  //\n  // On stack, before: ...\n  // On stack, after: program(guid), ...\n  //\n  // Push a program expression onto the stack. This takes\n  // a compile-time guid and converts it into a runtime-accessible\n  // expression.\n  pushProgram: function(guid) {\n    if (guid != null) {\n      this.pushStackLiteral(this.programExpression(guid));\n    } else {\n      this.pushStackLiteral(null);\n    }\n  },\n\n  // [registerDecorator]\n  //\n  // On stack, before: hash, program, params..., ...\n  // On stack, after: ...\n  //\n  // Pops off the decorator's parameters, invokes the decorator,\n  // and inserts the decorator into the decorators list.\n  registerDecorator(paramSize, name) {\n    let foundDecorator = this.nameLookup('decorators', name, 'decorator'),\n      options = this.setupHelperArgs(name, paramSize);\n\n    this.decorators.push([\n      'fn = ',\n      this.decorators.functionCall(foundDecorator, '', [\n        'fn',\n        'props',\n        'container',\n        options\n      ]),\n      ' || fn;'\n    ]);\n  },\n\n  // [invokeHelper]\n  //\n  // On stack, before: hash, inverse, program, params..., ...\n  // On stack, after: result of helper invocation\n  //\n  // Pops off the helper's parameters, invokes the helper,\n  // and pushes the helper's return value onto the stack.\n  //\n  // If the helper is not found, `helperMissing` is called.\n  invokeHelper: function(paramSize, name, isSimple) {\n    let nonHelper = this.popStack(),\n      helper = this.setupHelper(paramSize, name);\n\n    let possibleFunctionCalls = [];\n\n    if (isSimple) {\n      // direct call to helper\n      possibleFunctionCalls.push(helper.name);\n    }\n    // call a function from the input object\n    possibleFunctionCalls.push(nonHelper);\n    if (!this.options.strict) {\n      possibleFunctionCalls.push(\n        this.aliasable('container.hooks.helperMissing')\n      );\n    }\n\n    let functionLookupCode = [\n      '(',\n      this.itemsSeparatedBy(possibleFunctionCalls, '||'),\n      ')'\n    ];\n    let functionCall = this.source.functionCall(\n      functionLookupCode,\n      'call',\n      helper.callParams\n    );\n    this.push(functionCall);\n  },\n\n  itemsSeparatedBy: function(items, separator) {\n    let result = [];\n    result.push(items[0]);\n    for (let i = 1; i < items.length; i++) {\n      result.push(separator, items[i]);\n    }\n    return result;\n  },\n  // [invokeKnownHelper]\n  //\n  // On stack, before: hash, inverse, program, params..., ...\n  // On stack, after: result of helper invocation\n  //\n  // This operation is used when the helper is known to exist,\n  // so a `helperMissing` fallback is not required.\n  invokeKnownHelper: function(paramSize, name) {\n    let helper = this.setupHelper(paramSize, name);\n    this.push(this.source.functionCall(helper.name, 'call', helper.callParams));\n  },\n\n  // [invokeAmbiguous]\n  //\n  // On stack, before: hash, inverse, program, params..., ...\n  // On stack, after: result of disambiguation\n  //\n  // This operation is used when an expression like `{{foo}}`\n  // is provided, but we don't know at compile-time whether it\n  // is a helper or a path.\n  //\n  // This operation emits more code than the other options,\n  // and can be avoided by passing the `knownHelpers` and\n  // `knownHelpersOnly` flags at compile-time.\n  invokeAmbiguous: function(name, helperCall) {\n    this.useRegister('helper');\n\n    let nonHelper = this.popStack();\n\n    this.emptyHash();\n    let helper = this.setupHelper(0, name, helperCall);\n\n    let helperName = (this.lastHelper = this.nameLookup(\n      'helpers',\n      name,\n      'helper'\n    ));\n\n    let lookup = ['(', '(helper = ', helperName, ' || ', nonHelper, ')'];\n    if (!this.options.strict) {\n      lookup[0] = '(helper = ';\n      lookup.push(\n        ' != null ? helper : ',\n        this.aliasable('container.hooks.helperMissing')\n      );\n    }\n\n    this.push([\n      '(',\n      lookup,\n      helper.paramsInit ? ['),(', helper.paramsInit] : [],\n      '),',\n      '(typeof helper === ',\n      this.aliasable('\"function\"'),\n      ' ? ',\n      this.source.functionCall('helper', 'call', helper.callParams),\n      ' : helper))'\n    ]);\n  },\n\n  // [invokePartial]\n  //\n  // On stack, before: context, ...\n  // On stack after: result of partial invocation\n  //\n  // This operation pops off a context, invokes a partial with that context,\n  // and pushes the result of the invocation back.\n  invokePartial: function(isDynamic, name, indent) {\n    let params = [],\n      options = this.setupParams(name, 1, params);\n\n    if (isDynamic) {\n      name = this.popStack();\n      delete options.name;\n    }\n\n    if (indent) {\n      options.indent = JSON.stringify(indent);\n    }\n    options.helpers = 'helpers';\n    options.partials = 'partials';\n    options.decorators = 'container.decorators';\n\n    if (!isDynamic) {\n      params.unshift(this.nameLookup('partials', name, 'partial'));\n    } else {\n      params.unshift(name);\n    }\n\n    if (this.options.compat) {\n      options.depths = 'depths';\n    }\n    options = this.objectLiteral(options);\n    params.push(options);\n\n    this.push(this.source.functionCall('container.invokePartial', '', params));\n  },\n\n  // [assignToHash]\n  //\n  // On stack, before: value, ..., hash, ...\n  // On stack, after: ..., hash, ...\n  //\n  // Pops a value off the stack and assigns it to the current hash\n  assignToHash: function(key) {\n    let value = this.popStack(),\n      context,\n      type,\n      id;\n\n    if (this.trackIds) {\n      id = this.popStack();\n    }\n    if (this.stringParams) {\n      type = this.popStack();\n      context = this.popStack();\n    }\n\n    let hash = this.hash;\n    if (context) {\n      hash.contexts[key] = context;\n    }\n    if (type) {\n      hash.types[key] = type;\n    }\n    if (id) {\n      hash.ids[key] = id;\n    }\n    hash.values[key] = value;\n  },\n\n  pushId: function(type, name, child) {\n    if (type === 'BlockParam') {\n      this.pushStackLiteral(\n        'blockParams[' +\n          name[0] +\n          '].path[' +\n          name[1] +\n          ']' +\n          (child ? ' + ' + JSON.stringify('.' + child) : '')\n      );\n    } else if (type === 'PathExpression') {\n      this.pushString(name);\n    } else if (type === 'SubExpression') {\n      this.pushStackLiteral('true');\n    } else {\n      this.pushStackLiteral('null');\n    }\n  },\n\n  // HELPERS\n\n  compiler: JavaScriptCompiler,\n\n  compileChildren: function(environment, options) {\n    let children = environment.children,\n      child,\n      compiler;\n\n    for (let i = 0, l = children.length; i < l; i++) {\n      child = children[i];\n      compiler = new this.compiler(); // eslint-disable-line new-cap\n\n      let existing = this.matchExistingProgram(child);\n\n      if (existing == null) {\n        this.context.programs.push(''); // Placeholder to prevent name conflicts for nested children\n        let index = this.context.programs.length;\n        child.index = index;\n        child.name = 'program' + index;\n        this.context.programs[index] = compiler.compile(\n          child,\n          options,\n          this.context,\n          !this.precompile\n        );\n        this.context.decorators[index] = compiler.decorators;\n        this.context.environments[index] = child;\n\n        this.useDepths = this.useDepths || compiler.useDepths;\n        this.useBlockParams = this.useBlockParams || compiler.useBlockParams;\n        child.useDepths = this.useDepths;\n        child.useBlockParams = this.useBlockParams;\n      } else {\n        child.index = existing.index;\n        child.name = 'program' + existing.index;\n\n        this.useDepths = this.useDepths || existing.useDepths;\n        this.useBlockParams = this.useBlockParams || existing.useBlockParams;\n      }\n    }\n  },\n  matchExistingProgram: function(child) {\n    for (let i = 0, len = this.context.environments.length; i < len; i++) {\n      let environment = this.context.environments[i];\n      if (environment && environment.equals(child)) {\n        return environment;\n      }\n    }\n  },\n\n  programExpression: function(guid) {\n    let child = this.environment.children[guid],\n      programParams = [child.index, 'data', child.blockParams];\n\n    if (this.useBlockParams || this.useDepths) {\n      programParams.push('blockParams');\n    }\n    if (this.useDepths) {\n      programParams.push('depths');\n    }\n\n    return 'container.program(' + programParams.join(', ') + ')';\n  },\n\n  useRegister: function(name) {\n    if (!this.registers[name]) {\n      this.registers[name] = true;\n      this.registers.list.push(name);\n    }\n  },\n\n  push: function(expr) {\n    if (!(expr instanceof Literal)) {\n      expr = this.source.wrap(expr);\n    }\n\n    this.inlineStack.push(expr);\n    return expr;\n  },\n\n  pushStackLiteral: function(item) {\n    this.push(new Literal(item));\n  },\n\n  pushSource: function(source) {\n    if (this.pendingContent) {\n      this.source.push(\n        this.appendToBuffer(\n          this.source.quotedString(this.pendingContent),\n          this.pendingLocation\n        )\n      );\n      this.pendingContent = undefined;\n    }\n\n    if (source) {\n      this.source.push(source);\n    }\n  },\n\n  replaceStack: function(callback) {\n    let prefix = ['('],\n      stack,\n      createdStack,\n      usedLiteral;\n\n    /* istanbul ignore next */\n    if (!this.isInline()) {\n      throw new Exception('replaceStack on non-inline');\n    }\n\n    // We want to merge the inline statement into the replacement statement via ','\n    let top = this.popStack(true);\n\n    if (top instanceof Literal) {\n      // Literals do not need to be inlined\n      stack = [top.value];\n      prefix = ['(', stack];\n      usedLiteral = true;\n    } else {\n      // Get or create the current stack name for use by the inline\n      createdStack = true;\n      let name = this.incrStack();\n\n      prefix = ['((', this.push(name), ' = ', top, ')'];\n      stack = this.topStack();\n    }\n\n    let item = callback.call(this, stack);\n\n    if (!usedLiteral) {\n      this.popStack();\n    }\n    if (createdStack) {\n      this.stackSlot--;\n    }\n    this.push(prefix.concat(item, ')'));\n  },\n\n  incrStack: function() {\n    this.stackSlot++;\n    if (this.stackSlot > this.stackVars.length) {\n      this.stackVars.push('stack' + this.stackSlot);\n    }\n    return this.topStackName();\n  },\n  topStackName: function() {\n    return 'stack' + this.stackSlot;\n  },\n  flushInline: function() {\n    let inlineStack = this.inlineStack;\n    this.inlineStack = [];\n    for (let i = 0, len = inlineStack.length; i < len; i++) {\n      let entry = inlineStack[i];\n      /* istanbul ignore if */\n      if (entry instanceof Literal) {\n        this.compileStack.push(entry);\n      } else {\n        let stack = this.incrStack();\n        this.pushSource([stack, ' = ', entry, ';']);\n        this.compileStack.push(stack);\n      }\n    }\n  },\n  isInline: function() {\n    return this.inlineStack.length;\n  },\n\n  popStack: function(wrapped) {\n    let inline = this.isInline(),\n      item = (inline ? this.inlineStack : this.compileStack).pop();\n\n    if (!wrapped && item instanceof Literal) {\n      return item.value;\n    } else {\n      if (!inline) {\n        /* istanbul ignore next */\n        if (!this.stackSlot) {\n          throw new Exception('Invalid stack pop');\n        }\n        this.stackSlot--;\n      }\n      return item;\n    }\n  },\n\n  topStack: function() {\n    let stack = this.isInline() ? this.inlineStack : this.compileStack,\n      item = stack[stack.length - 1];\n\n    /* istanbul ignore if */\n    if (item instanceof Literal) {\n      return item.value;\n    } else {\n      return item;\n    }\n  },\n\n  contextName: function(context) {\n    if (this.useDepths && context) {\n      return 'depths[' + context + ']';\n    } else {\n      return 'depth' + context;\n    }\n  },\n\n  quotedString: function(str) {\n    return this.source.quotedString(str);\n  },\n\n  objectLiteral: function(obj) {\n    return this.source.objectLiteral(obj);\n  },\n\n  aliasable: function(name) {\n    let ret = this.aliases[name];\n    if (ret) {\n      ret.referenceCount++;\n      return ret;\n    }\n\n    ret = this.aliases[name] = this.source.wrap(name);\n    ret.aliasable = true;\n    ret.referenceCount = 1;\n\n    return ret;\n  },\n\n  setupHelper: function(paramSize, name, blockHelper) {\n    let params = [],\n      paramsInit = this.setupHelperArgs(name, paramSize, params, blockHelper);\n    let foundHelper = this.nameLookup('helpers', name, 'helper'),\n      callContext = this.aliasable(\n        `${this.contextName(0)} != null ? ${this.contextName(\n          0\n        )} : (container.nullContext || {})`\n      );\n\n    return {\n      params: params,\n      paramsInit: paramsInit,\n      name: foundHelper,\n      callParams: [callContext].concat(params)\n    };\n  },\n\n  setupParams: function(helper, paramSize, params) {\n    let options = {},\n      contexts = [],\n      types = [],\n      ids = [],\n      objectArgs = !params,\n      param;\n\n    if (objectArgs) {\n      params = [];\n    }\n\n    options.name = this.quotedString(helper);\n    options.hash = this.popStack();\n\n    if (this.trackIds) {\n      options.hashIds = this.popStack();\n    }\n    if (this.stringParams) {\n      options.hashTypes = this.popStack();\n      options.hashContexts = this.popStack();\n    }\n\n    let inverse = this.popStack(),\n      program = this.popStack();\n\n    // Avoid setting fn and inverse if neither are set. This allows\n    // helpers to do a check for `if (options.fn)`\n    if (program || inverse) {\n      options.fn = program || 'container.noop';\n      options.inverse = inverse || 'container.noop';\n    }\n\n    // The parameters go on to the stack in order (making sure that they are evaluated in order)\n    // so we need to pop them off the stack in reverse order\n    let i = paramSize;\n    while (i--) {\n      param = this.popStack();\n      params[i] = param;\n\n      if (this.trackIds) {\n        ids[i] = this.popStack();\n      }\n      if (this.stringParams) {\n        types[i] = this.popStack();\n        contexts[i] = this.popStack();\n      }\n    }\n\n    if (objectArgs) {\n      options.args = this.source.generateArray(params);\n    }\n\n    if (this.trackIds) {\n      options.ids = this.source.generateArray(ids);\n    }\n    if (this.stringParams) {\n      options.types = this.source.generateArray(types);\n      options.contexts = this.source.generateArray(contexts);\n    }\n\n    if (this.options.data) {\n      options.data = 'data';\n    }\n    if (this.useBlockParams) {\n      options.blockParams = 'blockParams';\n    }\n    return options;\n  },\n\n  setupHelperArgs: function(helper, paramSize, params, useRegister) {\n    let options = this.setupParams(helper, paramSize, params);\n    options.loc = JSON.stringify(this.source.currentLocation);\n    options = this.objectLiteral(options);\n    if (useRegister) {\n      this.useRegister('options');\n      params.push('options');\n      return ['options=', options];\n    } else if (params) {\n      params.push(options);\n      return '';\n    } else {\n      return options;\n    }\n  }\n};\n\n(function() {\n  const reservedWords = (\n    'break else new var' +\n    ' case finally return void' +\n    ' catch for switch while' +\n    ' continue function this with' +\n    ' default if throw' +\n    ' delete in try' +\n    ' do instanceof typeof' +\n    ' abstract enum int short' +\n    ' boolean export interface static' +\n    ' byte extends long super' +\n    ' char final native synchronized' +\n    ' class float package throws' +\n    ' const goto private transient' +\n    ' debugger implements protected volatile' +\n    ' double import public let yield await' +\n    ' null true false'\n  ).split(' ');\n\n  const compilerWords = (JavaScriptCompiler.RESERVED_WORDS = {});\n\n  for (let i = 0, l = reservedWords.length; i < l; i++) {\n    compilerWords[reservedWords[i]] = true;\n  }\n})();\n\n/**\n * @deprecated May be removed in the next major version\n */\nJavaScriptCompiler.isValidJavaScriptVariableName = function(name) {\n  return (\n    !JavaScriptCompiler.RESERVED_WORDS[name] &&\n    /^[a-zA-Z_$][0-9a-zA-Z_$]*$/.test(name)\n  );\n};\n\nfunction strictLookup(requireTerminal, compiler, parts, i, type) {\n  let stack = compiler.popStack(),\n    len = parts.length;\n  if (requireTerminal) {\n    len--;\n  }\n\n  for (; i < len; i++) {\n    stack = compiler.nameLookup(stack, parts[i], type);\n  }\n\n  if (requireTerminal) {\n    return [\n      compiler.aliasable('container.strict'),\n      '(',\n      stack,\n      ', ',\n      compiler.quotedString(parts[i]),\n      ', ',\n      JSON.stringify(compiler.source.currentLocation),\n      ' )'\n    ];\n  } else {\n    return stack;\n  }\n}\n\nexport default JavaScriptCompiler;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}